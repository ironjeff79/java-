package exception;
//运行结果 Exception in thread "main" java.lang.ArithmeticException: / by zero
/* 
   java的异常处理机制
   1.1 异常在java中以类和对象的形式存在，那么异常的继承结构是怎么样的？
   
      Object
      Object下有Throwable(可抛出的)   Throwable继承Object 不管是错误还是异常，都是可抛出的
      Throwable下有两个分支：Error(不可处理 直接推出JVM)和Exception(可处理的)
      
      所有的错误(Error)只要发生，Java程序只有一个结果那就是终止程序的执行。推出JVM，错误是不能处理的
      
      Exception下有两个分支 1.RuntimeException（运行时异常） 2.（Exception的直接子类）ExceptionSubClass
      
      **所有RuntimeException及子类都被称为运行时异常
      **所有Exception的直接子类都被称为编译时异常
      
      运行异常在编写程序阶段，你可以选择处理，也可以不处理。运行时异常发生概率较低。
      
      编译时异常是在编译时发生的吗？？不是。
      编译时异常是表示必须在编写程序的时候预先对这种异常进行处理，如果不处理编译器报错。
      
      
   1.2 编译时异常和运行时异常，都是发生在运行阶段，编译阶段异常是不会发生的。
      所有异常都是在运行阶段发生的，因为只有程序运行阶段才可以new对象。
      因为异常的发生就是new异常对象。    
   
   1.3 编译时异常和运行时异常的区别？
      编译时异常一般发生的概率比较高
          例：看到外面下雨，出门之前会预料到：如果不打伞可能会生病。而且异常发生的概率很高，所以出门会带伞。
              这就是对生病这种异常发生之前的一种处理方式。
              
              对于一些发生概率较高的异常，需要在运行之前对其进行预处理。
          
      运行时异常一般发生的概率比较低
          例：小明走在大街上，可能会被天上的飞机轮子砸到
          但是这种异常发生概率较低。出门之前没必要提前对这种发生概率较低的异常进行预处理。
          如果预处理这种异常，你将活的很累。
          
      假设java中没有对异常进行划分，没有分为编译时异常和运行时异常
      所有的异常都需要在编写程序阶段对其进行预处理，将会？
          首先程序绝对的安全。
          但是编写程序太累，到处都是处理异常的代码。
 
   1.4 编译时异常和运行时异常还有别的名字
      **运行时异常又被称为非受检异常，或者非受控异常。 UnCheckedException
      **编译时异常又被称为受检异常，还有叫做受控异常。 CheckedException         
   
   1.5 再次强调：所有异常都是发生在运行阶段。
   1.6 Java语言中对异常处理包括两种方式：
      第一种方式: 在方法声明的位置上，使用throws关键字，抛给上一级。
                 谁调用就抛给谁。 
      第二种方式：使用try..catch语句进行异常的捕捉。
                 这件事发生了，谁也不知道，因为给抓住了。
      
      思考：
         异常发生之后，如果我选择了上抛，抛给了我的调用者，调用者需要对这个异常继续处理，同样有两种方式。
   
   1.7 注意：Java中异常发生之后如果一直上抛，最终抛给了main方法，
             main方法继续向上抛，抛给了调用者JVM，JVM知道这个异常发生，只有一个结果，终止Java程序的执行。          
   
   
   2. 什么是UML?有什么用?
      UML是一种统一建模语言。一种图标式语言（画图的）
      UML不是只有Java中使用。只要是面向对象的编程语言，都有UML。
      一般画UML图的都是软件架构师或者系统分析师。
      
      在UML图中可以描述类和类之间的关系，程序执行的流程，对象的状态等
    
*/
public class Exception03 {
	public static void main(String[] args) {
		/*
		 程序执行到此处发生了ArithmeticException异常，
		 继承RuntimeException，属于运行时异常。
		 底层new了一个ArithmeticException异常对象。
		 然后抛出了，由于是main方法调用了100/0，
		 所以这个异常ArithmeticException抛给了main方法。
		 main方法没有处理，将这个异常自动抛给了JVM。
		 JVM最终终止程序的运行。

	    */
		System.out.println(100 / 0);
		
		//这里的HelloWorld没有输出，没有执行。
		System.out.println("HelloWorld");		
	}

}
